// Generated by CoffeeScript 1.6.3
var ASPECT, FAR, NEAR, PLAYER_RADIUS, VIEW_ANGLE, closest_point_on_seg, line_intersects_circ, msg, shivs;

VIEW_ANGLE = 70;

ASPECT = 1;

NEAR = 100;

FAR = 10000;

PLAYER_RADIUS = 110;

window.onload = function() {
  var $container, HEIGHT, WIDTH, animate, camera, cameras, color, colors, dir_vec, floor, has_webgl, hex, i, id_prefix, keyState, light, light2, lose_msg, material, mid, other_id, overhead_cam, peer, player_connections, player_id, player_id_full, player_names, players, point, process_draw, process_lose, process_win, render, renderer, resetCameraPositions, scene, scores, setup_other_conn, stop, teapot, teapotGeometry, wall, wallMaterial, wall_line, walls, walls_data, walls_vectors, win_msg, _i, _j, _k, _len, _len1;
  player_id_full = location.hash.slice(1);
  id_prefix = player_id_full.split('_')[0];
  player_id = player_id_full.split('_')[1];
  players = {};
  players[player_id] = void 0;
  player_connections = {};
  scores = {};
  keyState = {};
  peer = id_prefix === 'anus' ? new Peer(player_id_full, {
    host: 'localhost',
    port: 9000,
    debug: 3
  }) : new Peer(player_id_full, {
    key: 'bt01ki4in04tpgb9',
    debug: 3
  });
  console.log(peer);
  if (player_id !== "0") {
    other_id = "0";
    peer.on('open', function() {
      player_connections[other_id] = peer.connect(id_prefix + '_' + other_id);
      return setup_other_conn(other_id);
    });
  }
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;
  $container = $("#container");
  has_webgl = document.createElement('canvas').getContext('webgl');
  renderer = has_webgl ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();
  cameras = [new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR), new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR), new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR), new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR), new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR), new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR)];
  overhead_cam = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
  overhead_cam.position.y = 2000;
  overhead_cam.rotation.x = -Math.PI / 2;
  scene = new THREE.Scene();
  renderer.setSize(WIDTH, HEIGHT);
  $container.append('<div style="position: absolute; left: 0; font-size: 100px" id="scores"></div>');
  $container.append('<div style="position: absolute; left: 0; top: 200px; font-size: 100px" id="msg"></div>');
  $container.append(renderer.domElement);
  colors = [0xCC0000, 0x00CC00, 0x0000CC, 0xCCCC00, 0xCC00CC, 0x00CCCC];
  player_names = ["RED", "GREEN", "BLUE", "YELLOW", "PURPLE", "CYAN"];
  win_msg = "418 - You are a teapot.";
  lose_msg = "What?! You think this is a game?";
  teapotGeometry = new THREE.TeapotGeometry(100, true, true, true, true, true);
  resetCameraPositions = function() {
    var camera, i, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = cameras.length; _i < _len; i = ++_i) {
      camera = cameras[i];
      keyState[i] = {
        90: false,
        88: false,
        37: false,
        38: false,
        39: false,
        40: false
      };
      camera.position.x = 300 * (Math.floor(i / 2));
      camera.position.z = -900 * (i % 2);
      _results.push(camera.rotation.y = Math.PI * (i % 2));
    }
    return _results;
  };
  resetCameraPositions();
  for (i = _i = 0, _len = cameras.length; _i < _len; i = ++_i) {
    camera = cameras[i];
    color = colors[i % colors.length];
    hex = color.toString(16);
    hex = '000000'.substr(0, 6 - hex.length) + hex;
    scores[i] = 0;
    $('#scores').append('<span id="score' + i + '" style="color: #' + hex + '">0</div>');
    material = new THREE.MeshLambertMaterial({
      color: color
    });
    teapot = new THREE.Mesh(teapotGeometry, material);
    teapot.rotation.y = Math.PI / 2;
    camera.add(teapot);
    scene.add(camera);
  }
  wallMaterial = new THREE.MeshLambertMaterial(0xCCCCCC);
  wallMaterial.side = THREE.DoubleSide;
  floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), wallMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -100;
  scene.add(floor);
  walls_data = [];
  for (i = _j = 0; _j <= 4; i = _j += 1) {
    walls_data.push([[-150 + 300 * i, -800], [-150 + 300 * i, -1300]]);
    walls_data.push([[-150 + 300 * i, -100], [-150 + 300 * i, 400]]);
  }
  walls_vectors = (function() {
    var _k, _len1, _results;
    _results = [];
    for (_k = 0, _len1 = walls_data.length; _k < _len1; _k++) {
      wall = walls_data[_k];
      _results.push((function() {
        var _l, _len2, _results1;
        _results1 = [];
        for (_l = 0, _len2 = wall.length; _l < _len2; _l++) {
          point = wall[_l];
          _results1.push(new THREE.Vector2(point[0], point[1]));
        }
        return _results1;
      })());
    }
    return _results;
  })();
  walls = [];
  for (_k = 0, _len1 = walls_vectors.length; _k < _len1; _k++) {
    wall_line = walls_vectors[_k];
    dir_vec = wall_line[1].clone().sub(wall_line[0]);
    mid = wall_line[0].clone().lerp(wall_line[1], 0.5);
    console.log(wall_line, dir_vec);
    console.log(dir_vec.length());
    wall = new THREE.Mesh(new THREE.PlaneGeometry(dir_vec.length(), 500), wallMaterial);
    wall.rotation.y = -Math.atan(dir_vec.y / dir_vec.x);
    wall.position.x = mid.x;
    wall.position.z = mid.y;
    console.log('on and on just another wall in the', wall);
    scene.add(wall);
    walls.push(wall);
  }
  light = new THREE.PointLight(0xFFFFFF);
  light.position.x = 10;
  light.position.y = 50;
  light.position.z = 130;
  scene.add(light);
  light2 = new THREE.PointLight(0xFFFFFF);
  light2.position.x = -10;
  light2.position.y = 50;
  light2.position.z = -130;
  scene.add(light2);
  stop = function() {
    var player_connection, _results;
    _results = [];
    for (other_id in player_connections) {
      player_connection = player_connections[other_id];
      player_connection.send({
        event: 'keyState',
        player_id: player_id,
        player_keyState: {
          90: false,
          88: false,
          37: false,
          38: false,
          39: false,
          40: false
        }
      });
      _results.push(player_connection.send({
        event: 'move',
        player_id: player_id,
        position_x: cameras[player_id].position.x,
        position_y: cameras[player_id].position.y,
        position_z: cameras[player_id].position.z,
        rotation_x: cameras[player_id].rotation.x,
        rotation_y: cameras[player_id].rotation.y,
        rotation_z: cameras[player_id].rotation.z
      }));
    }
    return _results;
  };
  animate = function() {
    var code, k, old_position, other_camera, other_id_, pressed, shivved, shivver, _l, _len2, _ref;
    requestAnimationFrame(animate);
    old_position = cameras[player_id].position.clone();
    for (k in cameras) {
      camera = cameras[k];
      _ref = keyState[k];
      for (code in _ref) {
        pressed = _ref[code];
        if (pressed) {
          code = parseInt(code);
          switch (code) {
            case 90:
              camera.rotation.y += 0.1;
              break;
            case 88:
              camera.rotation.y -= 0.1;
              break;
            case 37:
              camera.position.x -= 10 * Math.cos(camera.rotation.y);
              camera.position.z += 10 * Math.sin(camera.rotation.y);
              break;
            case 38:
              camera.position.x -= 10 * Math.sin(camera.rotation.y);
              camera.position.z -= 10 * Math.cos(camera.rotation.y);
              break;
            case 39:
              camera.position.x += 10 * Math.cos(camera.rotation.y);
              camera.position.z -= 10 * Math.sin(camera.rotation.y);
              break;
            case 40:
              camera.position.x += 10 * Math.sin(camera.rotation.y);
              camera.position.z += 10 * Math.cos(camera.rotation.y);
          }
        }
      }
    }
    camera = cameras[player_id];
    for (_l = 0, _len2 = walls_vectors.length; _l < _len2; _l++) {
      wall_line = walls_vectors[_l];
      if (line_intersects_circ(wall_line[0], wall_line[1], new THREE.Vector2(camera.position.x, camera.position.z), PLAYER_RADIUS)) {
        console.log('Collision with', wall_line);
        camera.position = old_position;
        stop();
      }
    }
    for (other_id_ in cameras) {
      other_camera = cameras[other_id_];
      if (other_id_ === player_id) {
        continue;
      }
      if (player_id < other_id_) {
        shivver = shivs(camera, other_camera);
        shivved = shivs(other_camera, camera);
        if (shivver && shivved) {
          process_draw(player_id, other_id_);
        } else if (shivver) {
          process_win(player_id);
          process_lose(other_id_);
        } else if (shivved) {
          process_win(other_id_);
          process_lose(player_id);
        }
      }
      if (other_camera.position.clone().sub(camera.position).length() < PLAYER_RADIUS * 2) {
        console.log('Teapot collision');
        camera.position = old_position;
        stop();
      }
    }
    return render();
  };
  render = function() {
    var view_height, view_width, views_x, views_y, x, y, _l, _len2, _results;
    views_x = Math.ceil(Math.sqrt(cameras.length));
    views_y = (views_x - 1) * views_x >= cameras.length ? views_x - 1 : views_x;
    view_width = WIDTH / views_x;
    view_height = HEIGHT / views_y;
    if (has_webgl) {
      renderer.enableScissorTest(true);
      _results = [];
      for (i = _l = 0, _len2 = cameras.length; _l < _len2; i = ++_l) {
        camera = cameras[i];
        if (i === parseInt(player_id)) {
          continue;
        }
        x = i % views_x;
        y = Math.floor(i / views_x);
        camera.aspect = view_width / view_height;
        camera.updateProjectionMatrix();
        renderer.setViewport(x * view_width, y * view_height, view_width, view_height);
        renderer.setScissor(x * view_width, y * view_height, view_width, view_height);
        _results.push(renderer.render(scene, camera));
      }
      return _results;
    } else {
      overhead_cam.aspect = WIDTH / HEIGHT;
      overhead_cam.updateProjectionMatrix();
      return renderer.render(scene, overhead_cam);
    }
  };
  process_draw = function(id1, id2, remote) {
    var player_connection;
    if (remote == null) {
      remote = false;
    }
    resetCameraPositions();
    scores[id1] -= 1;
    $('#score' + id1).html(scores[id1]);
    scores[id2] -= 1;
    $('#score' + id2).html(scores[id2]);
    msg(player_names[id1] + ' drew with ' + player_names[id2]);
    if (!remote) {
      for (other_id in player_connections) {
        player_connection = player_connections[other_id];
        player_connection.send({
          event: 'draw',
          id1: id1,
          id2: id2
        });
      }
    }
    $('#teapour').get(0).currentTime = 0;
    return $('#teapour').get(0).play();
  };
  process_win = function(id, remote) {
    var player_connection;
    if (remote == null) {
      remote = false;
    }
    resetCameraPositions();
    scores[id] += 1;
    $('#score' + id).html(scores[id]);
    msg(player_names[id] + ' won');
    if (!remote) {
      for (other_id in player_connections) {
        player_connection = player_connections[other_id];
        player_connection.send({
          event: 'win',
          player_id: id
        });
      }
    }
    $('#teapour').get(0).currentTime = 0;
    return $('#teapour').get(0).play();
  };
  process_lose = function(id, remote) {
    var player_connection, _results;
    if (remote == null) {
      remote = false;
    }
    msg(player_names[id] + ' lost');
    if (!remote) {
      _results = [];
      for (other_id in player_connections) {
        player_connection = player_connections[other_id];
        _results.push(player_connection.send({
          event: 'lost',
          player_id: id
        }));
      }
      return _results;
    }
  };
  $(document).keydown(function(event) {
    var player_connection, _results;
    if (event.which in keyState[player_id]) {
      if (!keyState[player_id][event.which]) {
        keyState[player_id][event.which] = true;
        _results = [];
        for (other_id in player_connections) {
          player_connection = player_connections[other_id];
          _results.push(player_connection.send({
            event: 'keyState',
            player_id: player_id,
            player_keyState: keyState[player_id]
          }));
        }
        return _results;
      }
    }
  });
  $(document).keyup(function(event) {
    var player_connection, _results;
    if (event.which in keyState[player_id]) {
      keyState[player_id][event.which] = false;
      _results = [];
      for (other_id in player_connections) {
        player_connection = player_connections[other_id];
        player_connection.send({
          event: 'keyState',
          player_id: player_id,
          player_keyState: keyState[player_id]
        });
        _results.push(player_connection.send({
          event: 'move',
          player_id: player_id,
          position_x: cameras[player_id].position.x,
          position_y: cameras[player_id].position.y,
          position_z: cameras[player_id].position.z,
          rotation_x: cameras[player_id].rotation.x,
          rotation_y: cameras[player_id].rotation.y,
          rotation_z: cameras[player_id].rotation.z
        }));
      }
      return _results;
    }
  });
  peer.on('connection', function(conn) {
    var local_id;
    console.log(conn);
    local_id = conn.peer.split('_')[1];
    player_connections[local_id] = conn;
    return setup_other_conn(local_id);
  });
  setup_other_conn = function(other_id) {
    player_connections[other_id].on('open', function() {
      return player_connections[other_id].send({
        event: 'players',
        players: players
      });
    });
    return player_connections[other_id].on('data', function(data) {
      var k, v, _ref, _results;
      switch (data.event) {
        case 'move':
          cameras[data.player_id].position.x = data.position_x;
          cameras[data.player_id].position.y = data.position_y;
          cameras[data.player_id].position.z = data.position_z;
          cameras[data.player_id].rotation.x = data.rotation_x;
          cameras[data.player_id].rotation.y = data.rotation_y;
          return cameras[data.player_id].rotation.z = data.rotation_z;
        case 'players':
          _ref = data.players;
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            console.log(k, player_connections);
            if (!(k in player_connections) && player_id !== '0') {
              console.log('mooooooo');
              player_connections[k] = peer.connect(id_prefix + '_' + k);
              setup_other_conn(k);
            }
            _results.push(players[k] = v);
          }
          return _results;
          break;
        case 'win':
          return process_win(data.player_id, true);
        case 'draw':
          return process_draw(data.id1, data.id2, true);
        case 'lose':
          return process_lose(data.player_id, true);
        case 'keyState':
          return keyState[data.player_id] = data.player_keyState;
      }
    });
  };
  return animate();
};

closest_point_on_seg = function(seg_a, seg_b, circ_cent) {
  var closest, proj, proj_v, pt_v, seg_v, seg_v_unit;
  seg_v = seg_b.clone().sub(seg_a);
  pt_v = circ_cent.clone().sub(seg_a);
  seg_v_unit = seg_v.clone().divideScalar(seg_v.length());
  proj = pt_v.dot(seg_v_unit);
  if (proj <= 0) {
    return seg_a.clone();
  }
  if (proj >= seg_v.length()) {
    return seg_b.clone();
  }
  proj_v = seg_v_unit.clone().multiplyScalar(proj);
  closest = proj_v.clone().add(seg_a);
  return closest;
};

line_intersects_circ = function(seg_a, seg_b, circ_cent, r) {
  return circ_cent.clone().sub(closest_point_on_seg(seg_a, seg_b, circ_cent)).length() <= r;
};

shivs = function(camera, other_camera) {
  var direction, matrix;
  matrix = new THREE.Matrix4();
  matrix.extractRotation(camera.matrix);
  direction = new THREE.Vector3(0, 0, 1);
  direction.applyMatrix4(matrix);
  return line_intersects_circ(new THREE.Vector2(other_camera.position.x, other_camera.position.z), new THREE.Vector2(other_camera.position.x + 200 * direction.x, other_camera.position.z + 200 * direction.z), new THREE.Vector2(camera.position.x, camera.position.z), PLAYER_RADIUS);
};

msg = function(str) {
  return $('#msg').append($('<div></div>').html(str).delay(2000).fadeOut(1000, function() {
    return $(this).remove();
  }));
};

/*
//@ sourceMappingURL=main.map
*/
